spending mint_request_validator

/**
 * Role: protect customer funds
 *
 * Cancel validation rules:
 *   * must by signed by customer
 *  
 * Mint validation rules:
 *   * must be signed by master key
 *   * price is recent (as specified by the customer)
 *   * returned enough pbgs (as specified by the customer)
 *   * if price is higher than success fee cycle start price -> 
 *       return voucher ownership and send voucher to voucher validator (tokenName is request_id)
 * 
 * Reject validation rules:
 *   * must be signed by master key
 *   * returned enough lovelace to the customer (input minus max tx fees)
 */

import { Fees } from "./common/Fees.hl"
import { Keys } from "./common/Keys.hl"
import { Price } from "./common/Price.hl"
import { SuccessFeeCycle } from "./common/SuccessFeeCycle.hl"
import { MintRequestDatum } from "./common/MintRequestDatum.hl"
import { MintRequestRedeemer } from "./common/MintRequestRedeemer.hl"

func main(datum: MintRequestDatum, redeemer: MintRequestRedeemer, ctx: ScriptContext) -> Bool {
    tx: Tx = ctx.tx;
    ref_inputs: []TxInput = tx.ref_inputs;

    redeemer.switch{
        Cancel => {
            datum.is_signed_by_customer(tx).trace("signed by customer: ")
        },
        Mint => {
            keys  = Keys::from_inputs(ref_inputs);
            price = Price::from_inputs(ref_inputs);
            fees  = Fees::from_inputs(ref_inputs);
            cycle = SuccessFeeCycle::from_inputs(ref_inputs);

            keys.is_signed_by_master_key(tx).trace("signed by master: ")
            && price.is_recent(tx.time_range.end, datum.max_price_age).trace("price is recent: ")
            && datum.returned_enough_upon_mint(ctx, fees, price, cycle).trace("returned enough upon mint: ")
        },
        Reject => {
            keys = Keys::from_inputs(ref_inputs);
            fees = Fees::from_inputs(ref_inputs);

            keys.is_signed_by_master_key(tx)
            && datum.returned_enough_upon_rejection(ctx, fees)
        }
    }
}
