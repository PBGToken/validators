minting voucher_policy

/**
 * Role: scarcity of pbg-count in Vouchers
 *
 * General validation rules:
 *   * must be signed by master key
 *
 * Mint validation rules:
 *   * each non-empty token name exists as an input hash (request_id)
 *   * each non-empty token name must have a corresponding output voucher
 *   * the voucher token has qty 1
 *   * the ownership voucher has qty 1
 *   * lengths are consistent (vouchers minted vs ownership minted vs outputs with vouchers)
 *   * number of pbgs minted must correspond with total
 *   * voucher price is correct
 * 
 * Burn:
 *   * all minted quantities are negative (other rules are checked by other validators)
 */
 
import { Keys } from "./common/Keys.hl"
import { Price } from "./common/Price.hl"
import { Voucher } from "./common/Voucher.hl"
import { VoucherPolicyRedeemer } from "./common/VoucherPolicyRedeemer.hl"

func get_vouchers(tx: Tx, ac: AssetClass) -> []Voucher {
    tx.outputs.filter((output: TxOutput) -> {
        qty: Int = output.value.get_safe(ac);
        if (qty == 0) {
            false
        } else {
            assert(qty == 1, "unexpected mint quantity 1");
            true
        }
    }).map((output: TxOutput) -> Voucher {
        Voucher::from_data(output.datum.get_inline_data())
    })
}

func get_input_hashes(tx: Tx) -> []ByteArray {
    tx.inputs.map((input: TxInput) -> {
        input.output_id.serialize().blake2b()
    })
}

func main(redeemer: VoucherPolicyRedeemer, ctx: ScriptContext) -> Bool {
    tx:            Tx                = ctx.tx;
    ref_inputs:    []TxInput         = tx.ref_inputs;
    mph:           MintingPolicyHash = Scripts::voucher_policy;
    ac                               = AssetClass::new(mph, #);
    //print("getting all tokens");
    minted_tokens: Map[ByteArray]Int = tx.minted.get_policy(mph).delete(#);
    //print("getting number of vouchers for " + mph.show());
    n_tokens:      Int               = tx.minted.get(ac);
    
    
    keys  = Keys::from_inputs(ref_inputs);
    

    keys.is_signed_by_master_key(tx).trace("voucher policy mint signed by master: ")
    && redeemer.switch{
        Mint => {
            price = Price::from_inputs(ref_inputs);
            vouchers:   []Voucher = get_vouchers(tx, ac);
            n_vouchers: Int       = vouchers.length;
            input_hashes:  []ByteArray       = get_input_hashes(tx);
            assert(n_vouchers == minted_tokens.length, "inconsistent number of vouchers 1");
            assert(n_vouchers == n_tokens, "inconsistent number of vouchers 2");

            expected_pbgs: Int = minted_tokens.fold((prev: Int, token_name: ByteArray, qty: Int) -> {
                assert(qty == 1, "unexpected mint quantity 2");
                assert(input_hashes.any((hash: ByteArray) -> {hash == token_name}), "invalid token_name");

                voucher: Voucher = vouchers.find((voucher: Voucher) -> {voucher.token_name == token_name});
                assert(voucher.mint_price == price, "wrong voucher price");
                prev + voucher.pbgs
            }, 0);

            tx.minted.get(AssetClass::new(Scripts::pbg_policy, #)) >= expected_pbgs
        },
        Burn => {
            //print("burning..");
            n_tokens < 0
            && minted_tokens.all((_, qty: Int) -> {
                qty < 0
            })
        }
    }
}
