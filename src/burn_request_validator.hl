spending burn_request_validator

/**
 * Role: protect customer funds
 *
 * Cancel validation rules: 
 *   * tx is signed by the customer
 *
 * Burn validation rules:
 *   * tx is signed by master key
 *   * price is recent (as specified by the customer)
 *   * enough lovelace returned upon burn (taking into account vouchers)
 * 
 * Reject validation rules:
 *   * tx is signed by master key
 *   * enough returned (minus max tx fees)
 */

import { Fees } from "./common/Fees"
import { Keys } from "./common/Keys"
import { Price } from "./common/Price"
import { SuccessFeeCycle } from "./common/SuccessFeeCycle"
import { Voucher } from "./common/Voucher"
import { BurnRequestDatum, sum_reimbursements } from "./common/BurnRequestDatum"
import { BurnRequestRedeemer } from "./common/BurnRequestRedeemer"

func main(datum: BurnRequestDatum, redeemer: BurnRequestRedeemer, ctx: ScriptContext) -> Bool {
    tx: Tx = ctx.tx;
    ref_inputs: []TxInput = tx.ref_inputs;

    redeemer.switch{
        Cancel => {
            datum.is_signed_by_customer(tx)    
        },
        Burn{vouchers} => {
            keys  = Keys::from_inputs(ref_inputs);
            price = Price::from_inputs(ref_inputs);
            fees  = Fees::from_inputs(ref_inputs);
            cycle = SuccessFeeCycle::from_inputs(ref_inputs);

            keys.is_signed_by_master_key(tx).trace("signed by master: ")
            && price.is_recent(tx.time_range.end, datum.max_price_age).trace("price is recent: ")
            && datum.returned_enough_upon_burn(ctx, fees, price, cycle, vouchers).trace("returned enough: ")
        },
        Reject => {
            keys = Keys::from_inputs(ref_inputs);
            fees = Fees::from_inputs(ref_inputs);

            keys.is_signed_by_master_key(tx)
            && datum.returned_enough_upon_rejection(ctx, fees)
        }
    }
}
