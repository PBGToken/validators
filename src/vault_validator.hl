spending vault_validator

/**
 * Role: protect vault from losing value
 *
 * General validation rules:
 *   * tx is signed by master key
 *
 * Swap validation rules:
 *   * for each in entry in the vault diff:
 *       * asset counter is consumed
 *   * the lovelace sum (using the oracles) must be >= 0
 *   * minted is zero (to prevent asset tokens from begin destroyed in the same tx)
 *
 * Burn validation rules:
 *   * price must be recent
 *   * only lovelace was taken out of the vault
 *   * lovelace counter is consumed
 *   * lovelace from vault diff is negative
 *   * minted pbgs are negative
 *   * more-or-equal pbgs are burned than lovelace taken out of vault
 *   * no asset counters are minted/burned in the same transaction
 */

import { 
    MAX_PRICE_AGE
 } from "./common/constants"

import { 
	AssetsCounter
} from "./common/AssetsCounter"
import { VaultDatum } from "./common/VaultDatum"
import { Keys } from "./common/Keys"
import { Price } from "./common/Price"
import { PriceFeed } from "./common/PriceFeed"
import { Vault } from "./common/Vault"
import { VaultRedeemer } from "./common/VaultRedeemer"
import { Wiring, CURRENT_VERSION } from "./common/Wiring"

func upgrade_inputs_match_outputs(inputs: []TxInput, outputs: []TxOutput) -> Bool {
    if (inputs.is_empty()) {
        true
    } else {
        i: TxInput = inputs.head;
        o: TxOutput = outputs.head;
    
        if (i.datum == o.datum && i.value == o.value) {
            upgrade_inputs_match_outputs(inputs.tail, outputs.tail)
        } else {
            false
        }
    }
}

func main(datum: VaultDatum, redeemer: VaultRedeemer, ctx: ScriptContext) -> Bool {
    tx: Tx = ctx.tx;
    ref_inputs: []TxInput = tx.ref_inputs;

    keys = Keys::from_inputs(ref_inputs);

    assert(datum.is_asset(), "can't spend vault marker utxo");

    vault = Vault::from_hash(Scripts::vault_validator);
    diff: Value = vault.calc_diff(tx);

    keys.is_signed_by_master_key(tx)
    && redeemer.switch{
        Upgrade => {
            wiring = Wiring::from_ref_inputs(ref_inputs);
            new_vault_vh: ValidatorHash = wiring.vault.credential.switch{
                v: Validator => v.hash,
                _ => error("expected pubkey")
            };

            new_vault = Vault::from_hash(new_vault_vh);

            new_diff: Value = new_vault.calc_diff(tx);

            diff.to_map().for_each((mph: MintingPolicyHash, tokens: Map[ByteArray]Int) -> {
                tokens.for_each((tokenName: ByteArray, qty: Int) -> {
                    asset_class = AssetClass::new(mph, tokenName);
                    new_derived_asset_class = AssetClass::new(wiring.asset_counter_policy, asset_class.serialize().blake2b());

                    assert(qty < 0, "qty not negative");
                    assert(new_diff.get_safe(asset_class) == (-1)*qty, "new_qty != (-1)*old_qty");
                    assert(AssetsCounter::is_consumed(tx, asset_class), "old asset counter not consumed");
                    assert(tx.inputs.any((input: TxInput) -> {
                        input.value.get_safe(new_derived_asset_class) == 1
                    }), "new asset counter not consumed")
                })
            });

            wiring.version > CURRENT_VERSION
            && upgrade_inputs_match_outputs(tx.inputs, tx.outputs)
        },
        else => {
            Wiring::is_same_version(ref_inputs)
            && redeemer.switch{
                Swap{price_feeds} => {
                    lovelace_diff: Int = diff.to_map().fold((prev: Int, key: MintingPolicyHash, value: Map[ByteArray]Int) -> {
                        value.fold((prev_inner: Int, key_inner: ByteArray, qty: Int) -> {
                            asset_class = AssetClass::new(key, key_inner);
        
                            assert(AssetsCounter::is_consumed(tx, asset_class), "asset counter not consumed");
        
                            if (key == MintingPolicyHash::new(#) && key_inner == #) {
                                // lovelace
                                prev_inner + qty
                            } else {
                                print("looking for PriceFeed of " + asset_class.show());

                                // not lovelace
                                price: Price = PriceFeed::find_price(tx, price_feeds, asset_class);
        
                                prev_inner + price.convert_asset_to_lovelace(qty)
                            }
                        }, prev)
                    }, 0);
        
                    //print("MINTED: " + tx.minted.show());
        
                    keys.is_signed_by_oracles(tx).trace("signed by oracles: ")
                    && (lovelace_diff >= 0).trace("lovelace diff (" + lovelace_diff.show() + ") >= 0: ")
                    && tx.minted.is_zero().trace("nothing minted: ")
                },
                Burn => {
                    price = Price::from_inputs(ref_inputs); // main pbg price
                    lovelace: Int = diff.get_lovelace();
                    pbgs: Int = tx.minted.get(AssetClass::new(Scripts::pbg_policy, #));
        
                    //print("minted pbgs: " + pbgs.show());
        
                    price.is_recent(tx.time_range.end, MAX_PRICE_AGE).trace("price is recent: ")
                    && diff.get_assets().is_zero().trace("only lovelace taken from vault: ")
                    && AssetsCounter::lovelace_counter_is_consumed(tx).trace("lovelace counter consumed: ")
                    && (lovelace < 0).trace("lovelace is negative: ")
                    && (pbgs < 0).trace("pbgs negative: ")
                    && ((-pbgs) >= price.convert_lovelace_to_asset(-lovelace)).trace("more pbgs destroyed than lovelace taken out: ")
                    && !tx.minted.contains_policy(Scripts::assets_counter_policy).trace("no asset counters minted/burned: ")
                },
                else => error("unexpected")
            }
        }
        
    }
}
