module Tokens

import Addresses
import TokenNames

const direct_policy = MintingPolicyHash::from_script_hash(Scripts::fund_policy)

// as a function because it can fail
func indirect_policy() -> MintingPolicyHash {
    tx = ScriptContext::tx;
    input = tx.get_current_input();
    
    // ignores ADA
    input.value.get_singleton_asset_class().mph // this is why it is important that these UTxOs only contain a single policy
}

const policy: MintingPolicyHash = ScriptContext::current_script.switch{
    fund_policy => direct_policy,
    mint_order_validator => direct_policy,
    burn_order_validator => direct_policy,
    supply_validator => indirect_policy(),
    assets_validator => indirect_policy(),
    portfolio_validator => indirect_policy(),
    price_validator => indirect_policy(),
    reimbursement_validator => {
        tx = ScriptContext::tx;
        input = tx.get_current_input();
        input.value.to_map().delete(MintingPolicyHash::new(#)).get_singleton().first
    },
    voucher_validator => indirect_policy(),
    config_validator => indirect_policy(),
    metadata_validator => indirect_policy(),
    oracle_delegate => direct_policy,
    benchmark_delegate => direct_policy,
    governance_delegate => direct_policy
}

const dvp_token: AssetClass = AssetClass::new(policy, TokenNames::dvp_token)
const metadata: AssetClass = AssetClass::new(policy, TokenNames::metadata)
const config: AssetClass = AssetClass::new(policy, TokenNames::config)
const portfolio: AssetClass = AssetClass::new(policy, TokenNames::portfolio)
const price: AssetClass = AssetClass::new(policy, TokenNames::price)
const supply: AssetClass = AssetClass::new(policy, TokenNames::supply)

func voucher_ref_token(id: Int) -> AssetClass {
    AssetClass::new(policy, TokenNames::voucher_reference(id))
}

func voucher_user_nft(id: Int) -> AssetClass {
    AssetClass::new(policy, TokenNames::voucher_user_nft(id))
}