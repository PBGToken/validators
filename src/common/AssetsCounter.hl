module common_AssetsCounter

import { PARAMETER_POLICY } from "./constants.hl"

import {
    AssetsCounterDatum
} from "./AssetsCounterDatum.hl"

const ASSETS_COUNTER_MARKER_POLICY: MintingPolicyHash = PARAMETER_POLICY
const ASSETS_COUNTER_MARKER_ASSETCLASS: AssetClass = AssetClass::new(ASSETS_COUNTER_MARKER_POLICY, (9).show().encode_utf8())
const ASSETS_COUNTER_MARKER_TOKEN: Value = Value::new(ASSETS_COUNTER_MARKER_ASSETCLASS, 1)

const LOVELACE_COUNTER_ASSETCLASS: AssetClass = AssetClass::new(Scripts::assets_counter_policy, AssetClass::ADA.serialize().blake2b())
const LOVELACE_COUNTER_TOKEN: Value = Value::new(LOVELACE_COUNTER_ASSETCLASS, 1)

func getAssetCounterToken(assetclass: AssetClass) -> Value {
    derived_token_name: ByteArray = assetclass.serialize().blake2b();
    derived_asset_class = AssetClass::new(Scripts::assets_counter_policy, derived_token_name);
    
    Value::new(derived_asset_class, 1)
}

struct AssetsCounter {
    address: Address

    func from_ref_inputs(ref_inputs: []TxInput) -> AssetsCounter {
        d: Data = ref_inputs.find((input: TxInput) -> {
            input.output.value.get_safe(ASSETS_COUNTER_MARKER_ASSETCLASS) == 1
        }).output.datum.get_inline_data();

        AssetsCounter::from_data(d)
    }

    func lovelace_counter_is_consumed(tx: Tx) -> Bool {
        tx.inputs.any((input: TxInput) -> {
            input.output.value.get_safe(LOVELACE_COUNTER_ASSETCLASS) == 1
        })
    }

    func is_consumed(tx: Tx, asset_class: AssetClass) -> Bool {
        if (asset_class.mph == MintingPolicyHash::new(#) && asset_class.token_name == #) {
            AssetsCounter::lovelace_counter_is_consumed(tx)
        } else {
            token_name: ByteArray = asset_class.serialize().blake2b();

            tx.inputs.any((input: TxInput) -> {
                input.output.value.get_safe(AssetClass::new(Scripts::assets_counter_policy, token_name)) > 0
            })
        }
    }

    func get_count(self, tx: Tx, assetclass: AssetClass) -> (Int, Time) {
        derived_token_name: ByteArray = assetclass.serialize().blake2b();
        derived_asset_class    = AssetClass::new(Scripts::assets_counter_policy, derived_token_name);

        counter: TxInput = tx.ref_inputs.find((ref_input: TxInput) -> {
            ref_input.output.value.get_safe(derived_asset_class) == 1
            && ref_input.output.address == self.address
        });

        AssetsCounterDatum{count, timestamp} = AssetsCounterDatum::from_data(counter.output.datum.get_inline_data());

        (count, timestamp)
    }
}