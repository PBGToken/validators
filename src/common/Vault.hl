module common_Vault

import { PARAMETER_POLICY } from "./constants"
import { VAULT_STAKING_CREDENTIAL }  from "./addresses"
import { VaultDatum } from "./VaultDatum"

const VAULT_MARKER_POLICY: MintingPolicyHash = PARAMETER_POLICY
const VAULT_MARKER_ASSETCLASS: AssetClass = AssetClass::new(VAULT_MARKER_POLICY, (8).show().encode_utf8())
const VAULT_MARKER_TOKEN: Value = Value::new(VAULT_MARKER_ASSETCLASS, 1)

struct Vault {
    address: Address

    func from_hash(vh: ValidatorHash) -> Vault {
        Vault{Address::new(Credential::Validator{vh}, VAULT_STAKING_CREDENTIAL)}
    }

    func from_inputs(ref_inputs: []TxInput) -> Vault {
        output: TxOutput = ref_inputs.find((input: TxInput) -> {
            input.output.value.get_safe(VAULT_MARKER_ASSETCLASS) == 1
        }).output;

        assert(VaultDatum::from_data(output.datum.get_inline_data()) == VaultDatum::Marker, "invalid marker");

        Vault{output.address}
    }

    func calc_diff(self, tx: Tx) -> Value {
        a: Address = self.address;
        d = VaultDatum::Asset;

        // value coming out of the address goes into this tx
        out: Value = tx.inputs.fold((prev: Value, input: TxInput) -> {
            if (input.output.address == a) {
                prev + input.output.value
            } else {
                prev
            }
        }, Value::ZERO);

        // value going into the address, goes out of this tx
        in: Value = tx.outputs.fold((prev: Value, output: TxOutput) -> {
            if (output.address == a && VaultDatum::from_data(output.datum.get_inline_data()) == d) {
                prev + output.value
            } else {
                prev
            }
        }, Value::ZERO);
        
        //print("input: " + in.show());
        //print("output: " + out.show());
        in - out
    }
}
