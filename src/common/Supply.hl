module mSupply

import Addresses
import Tokens

import { Config } from mConfig

struct SuccessFeeState {
    period_id: Int
    start_time: Time
    period: Duration
    start_price: Ratio
}

struct Supply {
    tick: Int
    n_tokens: Int
    n_vouchers: Int
    n_lovelace: Int
    management_fee_timestamp: Time
    success_fee: SuccessFeeState

    func get_input() -> Supply {
        tx = ScriptContext::tx;

        input = ScriptContext::current_script.switch{
            supply_validator => tx.get_current_input(),
            config_validator => tx.get_any_input_at(Addresses::supply),
            else => tx.get_input_at(Addresses::supply)
        }

        assert(input.value.get(Tokens::supply) == 1, "doesn't contain the supply token");

        input.datum.inline.as[Supply]
    }

    func get_output() -> Supply {
        tx = ScriptContext::tx;

        output = tx.get_output_at(Addresses::supply);

        assert(output.value.contains_only(TokenNames::supply), "expected only the supply token");

        output.datum.inline.as[Supply]
    }

    func get_thread() -> (Supply, Supply) {
        (
            Supply::get_input(),
            Supply::get_output()
        )
    }

    func is_successful(self, price_relative_to_benchmark: Ratio) -> {
        price_relative_to_benchmark > self.success_fee.start_price
    }

    func period_end(self) -> Time {
        self.success_fee.start_time + self.success_fee.period
    }
    
    func period_id(self) -> Int {
        self.success_fee.period_id
    }
}