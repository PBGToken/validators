module common_MintRequestDatum

import {
    GOVERNANCE_ADDR,
	VOUCHER_VALIDATOR_ADDR
} from "./addresses"

import { Fees, FEES_PARAMETER_TOKEN } from "./Fees"
import { Price } from "./Price"
import { SuccessFeeCycle } from "./SuccessFeeCycle"
import { Voucher } from "./Voucher"

struct MintRequestDatum {
    customer_address:  Address
    max_rejection_fee: Int // in lovelace
    min_minted_pbgs:   Int // minimum number of PBG tokens expected to avoid too much slippage
    max_price_age:     Duration

    func get_customer_key(self) -> PubKeyHash {
        self.customer_address.credential.switch{
			pk: PubKey => pk.hash,
			_ => error("expected pubkey")
		}
    }

    func is_signed_by_customer(self, tx: Tx) -> Bool {
        tx.is_signed_by(self.get_customer_key())
    }

    // to avoid double satisfaction, the output must be datum tagged with a unique piece of data
    func sum_returned_value(self, tx: Tx, request_id: ByteArray) -> Value {
        tx.value_paid_to(self.customer_address, request_id)
    }

    func calc_return_n_pbgs_upon_mint(input: TxInput, fees: Fees, price: Price) -> Int {
        input_lovelace: Int       = input.value.get_lovelace();
        after_fees:     Int       = fees.subtract_mint_fee(input_lovelace);
        price.convert_lovelace_to_asset(after_fees)
    }

    func returned_enough_upon_mint(self, ctx: ScriptContext, fees: Fees, price: Price, cycle: SuccessFeeCycle) -> Bool {
        tx:             Tx        = ctx.tx;
        current_input:  TxInput   = ctx.get_current_input();
        request_id:     ByteArray = current_input.output_id.serialize().blake2b(); // use a hash so it fits in the token_name field of an AssetClass

        //print("calculating n_pbgs");
        n_pbgs:         Int       = MintRequestDatum::calc_return_n_pbgs_upon_mint(current_input, fees, price);

        //print("summing request_id utxos");
        return_value:   Value     = self.sum_returned_value(tx, request_id);

        //print("summed " + return_value.show());
        //print("n pbgs: " + n_pbgs.show());

        (return_value.get_safe(AssetClass::new(Scripts::pbg_policy, #)) >= n_pbgs).trace("enough returned: ")
        && (n_pbgs >= self.min_minted_pbgs).trace("enough minted: ")
        && if (price.gt(cycle.start_price)) {
            //print("sending vouchers to user");
            voucher = Voucher::new(
                self.customer_address,
                n_pbgs,
                price,
                request_id,
                cycle.id
            );

            return_voucher_ac     = AssetClass::new(Scripts::voucher_policy, request_id);
            validated_voucher_ac  = AssetClass::new(Scripts::voucher_policy, #);

            (return_value.get(return_voucher_ac) == 1).trace("returned voucher: ")
            && (tx.value_paid_to(VOUCHER_VALIDATOR_ADDR, voucher).get(validated_voucher_ac) == 1).trace("stored voucher: ")
        } else {
            true
        }
    }

    func calc_return_value_upon_rejection(self, input: TxInput, fees: Fees) -> Value {
        max_rejection_fee: Value     = fees.calc_max_mint_rejection_fee(self.max_rejection_fee);
        input.value - max_rejection_fee
    }

    func returned_enough_upon_rejection(self, ctx: ScriptContext, fees: Fees) -> Bool {
        tx:                Tx        = ctx.tx;
        current_input:     TxInput   = ctx.get_current_input();
        request_id:        ByteArray = current_input.output_id.serialize().blake2b();
        return_value:      Value     = self.sum_returned_value(tx, request_id);
        expected_return_value: Value = self.calc_return_value_upon_rejection(current_input, fees);
        return_value.contains(expected_return_value)
    }

    /**
     * price: lovelace per asset
     */
    func new(price: Real, lovelace: Int, slippage: Real, ctx: ContractContext) -> MintRequestDatum {
        ga: Address = GOVERNANCE_ADDR;
        fees_input: TxInput = ctx.network.pick(ga, FEES_PARAMETER_TOKEN).get_singleton();
    
        fees = Fees::from_data(fees_input.datum.get_inline_data());
    
        after_fees: Int = fees.subtract_mint_fee(lovelace);
        n_pbgs:     Int = ((1.0 - slippage)*(after_fees.to_real()/price)).floor();
    
        max_rejection_fee: Int = 1_000_000;
    
        MintRequestDatum{
            ctx.agent.address,
            max_rejection_fee,
            n_pbgs,
            12*Duration::HOUR
        }
    }
}
