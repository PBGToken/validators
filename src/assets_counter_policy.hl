minting assets_counter_policy

/**
 * Role: scarcity of asset counters
 *
 * Mint validation rules:
 *   * tx is signed by master key
 *   * only mint 1 per tx
 *   * enough collateral in output
 *   * datum has total set to 0
 *   * datum has timestamp after current time
 *   * must be sent to assets counter address (using marker)
 * 
 * Burn validation rules:
 *   * always allowed (so that BurnDuplicate isn't hindered)
 */

import {
    MIN_ASSET_COUNTER_COLLATERAL
} from "./common/constants"

import { AssetsCounter } from "./common/AssetsCounter"
import { AssetsCounterDatum } from "./common/AssetsCounterDatum"
import { AssetsCounterPolicyRedeemer } from "./common/AssetsCounterPolicyRedeemer"
import { Keys } from "./common/Keys"
import { Wiring } from "./common/Wiring"

func main(redeemer: AssetsCounterPolicyRedeemer, ctx: ScriptContext) -> Bool {
    tx: Tx = ctx.tx;
    ref_inputs: []TxInput = tx.ref_inputs;
    policy: MintingPolicyHash = Scripts::assets_counter_policy;

    redeemer.switch{
        Mint => {
            keys = Keys::from_inputs(ref_inputs);

            tokens: Map[ByteArray]Int = tx.minted.get_policy(policy);
            assert(tokens.tail.is_empty() && tokens.head_value == 1, "can only mint 1");
        
            token_name: ByteArray = tokens.head_key;
            derived_asset_class = AssetClass::new(policy, token_name);

            output: TxOutput = tx.outputs.find((output: TxOutput) -> {
                output.value.get_safe(derived_asset_class) >= 1
            });

            datum = AssetsCounterDatum::from_data(output.datum.get_inline_data());

            asset_counter = AssetsCounter::from_ref_inputs(ref_inputs);

            //print(output.address.credential.switch{v: Validator => v.hash.show(), _ => error("not a validator")} + "\n");
            //print(asset_counter.serialize().show() + "\n");
            Wiring::is_same_version(ref_inputs)
            && keys.is_signed_by_master_key(tx).trace("is_signed_by_master_key: ")
            && (output.value.get_lovelace() >= MIN_ASSET_COUNTER_COLLATERAL).trace("sufficient collateral: ")
            && (output.address == asset_counter.address).trace("sent to correct address: ")
            && (datum.count == 0).trace("init count ok: ")
            && (datum.timestamp >= tx.time_range.end)
        },
        Burn => {
            true
        }
    }
}
