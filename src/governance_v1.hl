spending governance_v1

/**
 * Role: protect parameters with time-delay (make sure parameters are updated/upgraded after 2 weeks of vote delay)
 *
 * General validation rules:
 *   * tx is signed by master key
 *   * 1 (and only 1) of the ref inputs is a vote intent UTxO
 *   * the vote intent valid_after property must be before time_range.start
 *   * the vote intent valid_after property can't be after time_range.start + 1 WEEK
 *
 * Update validation rules:
 *   * there must be precisely one output that contains the marker assetclass
 *   * that output must have precisely the inline datum as specified by the vote intent
 *   * output must be sent back to governance address
 *
 * Upgrade validation rules:
 *   * current input must be sent to new address with same datum
 *   * current input only contains one marker
 */

import { VOTE_INTENT_ASSETCLASS } from "./common/constants"
import { GOVERNANCE_ADDR } from "./common/addresses"
import { Keys } from "./common/Keys"
import { VoteDatum, VoteDatumPayload } from "./common/VoteDatum"

enum Redeemer {
    Update
    Upgrade
}

func get_param_output(tx: Tx, marker: AssetClass, address: Address) -> TxOutput { 
    tx.outputs.filter((output: TxOutput) -> Bool {
        qty: Int = output.value.get_safe(marker);
        if (qty > 0) {
            assert(qty == 1, "expected a single token");
            output.address == address
        } else {
            false
        }
    }).get_singleton()
}

func get_current_marker(current_input: TxInput) -> AssetClass {
    non_lovelace_assets: Map[MintingPolicyHash]Map[ByteArray]Int = current_input.output.value.get_assets().to_map();
    assert(non_lovelace_assets.tail.is_empty() && non_lovelace_assets.head_value.head_value == 1, "unexpected tokens");

    AssetClass::new(non_lovelace_assets.head_key, non_lovelace_assets.head_value.head_key)
}

func main(datum: Data, redeemer: Redeemer, ctx: ScriptContext) -> Bool {
    tx: Tx = ctx.tx;
    ref_inputs: []TxInput = tx.ref_inputs;
    keys = Keys::from_inputs(ref_inputs);

    vote_datum = VoteDatum::from_inputs(ref_inputs);
    vote_time_range: TimeRange = vote_datum.get_time_range();

    keys.is_signed_by_master_key(tx)
    && vote_time_range.contains(tx.time_range.start)
    && redeemer.switch{
        Update => {
            VoteDatumPayload::Update{marker, update_data} = vote_datum.payload;

            param_output: TxOutput = get_param_output(tx, marker, GOVERNANCE_ADDR);

            param_output.datum.get_inline_data() == update_data
        },
        Upgrade => {
            VoteDatumPayload::Upgrade{upgrade_address} = vote_datum.payload;
            current_input:      TxInput                = ctx.get_current_input();
            marker:             AssetClass             = get_current_marker(current_input);
            param_output:       TxOutput               = get_param_output(tx, marker, upgrade_address);

            param_output.datum.get_inline_data() == datum
        }
    }
}
