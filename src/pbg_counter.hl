spending pbg_counter

/**
 * Role: count circulating supply of PBGs and internal vouchers
 *
 * Validation rules:
 *   * signed by master key
 *   * current input contains counter token
 *   * output that contains the counter token has the correct datum
 *       * total pbgs increased/decreased with number of minted pbgs
 *       * total vouchers increased/decreased with number of vouchers
 */

import { 
    PBG_COUNTER_ASSETCLASS,
    MAX_PRICE_AGE,
    MANAGEMENT_FEE_CYCLE_ASSETCLASS
} from "./common/constants"
import { PBG_COUNTER_ADDR } from "./common/addresses"
import { AssetsCounter } from "./common/AssetsCounter"
import { PbgCountDatum } from "./common/PbgCountDatum"
import { Keys } from "./common/Keys"
import { Fees } from "./common/Fees"
import { Price } from "./common/Price"
import { SuccessFeeDistributorDatum } from "./common/SuccessFeeDistributorDatum"
import { PbgCounterRedeemer } from "./common/PbgCounterRedeemer"
import { Vault } from "./common/Vault"
import { CURRENT_VERSION, Wiring } from "./common/Wiring"

import { 
    SuccessFeeCycle,
    SUCCESS_FEE_CYCLE_TOKEN
} from "./common/SuccessFeeCycle"

func management_fee_cycle_is_consumed(tx: Tx) -> Bool {
    tx.inputs.any((input: TxInput) -> {
        input.output.value.get_safe(MANAGEMENT_FEE_CYCLE_ASSETCLASS) == 1
    })
}

func main(datum: PbgCountDatum, redeemer: PbgCounterRedeemer, ctx: ScriptContext) -> Bool {
    tx:          Tx        = ctx.tx;
    ref_inputs:  []TxInput = tx.ref_inputs;
    policy: MintingPolicyHash = Scripts::pbg_policy;
    assetclass = AssetClass::new(policy, #);
    minted_pbgs: Int       = tx.minted.get_safe(assetclass);
    minted_vouchers: Int   = tx.minted.get_safe(AssetClass::new(Scripts::voucher_policy, #));
    
    //print("looking for keys inputs");
	keys = Keys::from_inputs(ref_inputs);
   
    output: TxOutput = tx.outputs.find((output: TxOutput) -> {
        output.value.get_safe(PBG_COUNTER_ASSETCLASS) == 1
    });

    new_datum = PbgCountDatum::from_data(output.datum.get_inline_data());

    //print("old count: " + datum.total_pbgs.show());
    //print("minted: " + minted_pbgs.show() + ", " + minted_vouchers.show());
    //print("new count: " + new_datum.total_pbgs.show() + ", " + new_datum.total_vouchers.show());

    keys.is_signed_by_master_key(tx).trace("signed by master: ")
    && (ctx.get_current_input().value.get(PBG_COUNTER_ASSETCLASS) == 1).trace("input contains token: ")
    && redeemer.switch{
        Upgrade => {
            wiring = Wiring::from_ref_inputs(ref_inputs);
            
            wiring.version > CURRENT_VERSION
            && minted_pbgs == 0
            && minted_vouchers == 0
            && datum.total_vouchers == 0
            && output.address == wiring.pbg_counter
            && new_datum == datum
        },
        else => {
            Wiring::is_same_version(ref_inputs)
            && output.address == PBG_COUNTER_ADDR
            && (new_datum.total_pbgs == datum.total_pbgs + minted_pbgs).trace("new datum count increased: ")
            && (new_datum.total_vouchers == datum.total_vouchers + minted_vouchers).trace("new datum voucher count increased: ")
            && redeemer.switch{
                Vouchers => {
                    minted_pbgs == 0
                },
                else => {
                    //print("getting price ref input");
                    price = Price::from_inputs(ref_inputs);

                    price.is_recent(tx.time_range.end, MAX_PRICE_AGE).trace("price is recent: ")
                    && redeemer.switch{
                        Mint => {
                            vault = Vault::from_inputs(ref_inputs);
                            diff: Value = vault.calc_diff(tx);
                
                            (minted_pbgs > 0).trace("minted pbgs positive: ")
                            && (diff.get_lovelace() >= price.convert_asset_to_lovelace(minted_pbgs)).trace("vault increased: ")
                            && AssetsCounter::lovelace_counter_is_consumed(tx).trace("lovelace counter consumed: ")
                        },
                        Burn => {
                            vault = Vault::from_inputs(ref_inputs);
                            diff: Value = vault.calc_diff(tx);
                
                            (minted_pbgs < 0).trace("minted pbgs negative: ")
                            && ((diff.get_lovelace()*(-1)) >= price.convert_asset_to_lovelace(-minted_pbgs)).trace("more taken out of vault than burned: ")
                            && (AssetsCounter::lovelace_counter_is_consumed(tx)).trace("lovelace counter consumed: ")
                        },
                        MintManagementFee => {
                            fees = Fees::from_inputs(ref_inputs);
                
                            (minted_pbgs > 0).trace("positive minted pbgs: ")
                            && management_fee_cycle_is_consumed(tx) // so we are sure we can only do this once per day
                            && minted_pbgs <= fees.calc_management_fee(price.total_asset)
                        },
                        MintSuccessFee => {
                            cycle = SuccessFeeCycle::from_inputs(tx.inputs);
                            dst: Address = SuccessFeeDistributorDatum::get_address(tx);
                
                            minted_pbgs > 0
                            && SuccessFeeCycle::is_consumed(tx)
                            && minted_pbgs <= cycle.calc_final_success_fee(price)
                            && tx.value_paid_to(dst, SuccessFeeDistributorDatum::Asset).get(assetclass) >= minted_pbgs
                        },
                        else => error("unexpected")
                    }
                }
            }
        }   
    }
}
